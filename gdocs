#!/usr/bin/env python3

import re
import subprocess
from pathlib import Path

OUTPUT_FILE = "generated_docs.txt"


def read_existing_doc():
    path = Path("GEMINI.md")
    if path.exists():
        return path.read_text(encoding="utf-8")
    return ""


def build_prompt(existing_doc: str) -> str:
    return f"""
You are analyzing a software project directory.

EXISTING DOCUMENT (if any):
------------------------------------------------------------
{existing_doc}
------------------------------------------------------------

MODE DETECTION:
- If the EXISTING DOCUMENT section above is empty, generate GEMINI.md from scratch.
- If it contains content, update it based on the current project state.
- When updating:
  - Preserve useful structure.
  - Remove outdated information.
  - Add newly detected modules/features.
  - Do not duplicate sections.
  - Improve clarity and technical accuracy.

ANALYSIS SCOPE:
1. Inspect folder structure
2. Inspect source code
3. Inspect dependency files (package.json, requirements.txt, pyproject.toml, go.mod, Cargo.toml, etc.)
4. Inspect Dockerfile, CI/CD configs, infra configs
5. Detect:
   - Project type
   - Languages & frameworks
   - API routes
   - Auth mechanisms
   - Database usage
   - CLI commands
   - Background workers
   - Frontend
   - Infrastructure

STRICT RULES:
- Only document what actually exists in the repository.
- Do NOT hallucinate features.
- Skip irrelevant sections.
- Keep documentation technical, structured, and concise.

FILES TO GENERATE OR UPDATE (only if applicable):

- GEMINI.md
- docs/architecture.md
- docs/api.md
- docs/auth-flow.md
- docs/database.md
- docs/cli.md
- docs/frontend.md
- docs/infrastructure.md
- docs/dependencies.md
- Any other clearly relevant documentation file

OUTPUT FORMAT (MANDATORY):

=== FILE: relative/path/to/file ===
<file content>

No explanations.
No commentary.
No markdown outside file blocks.
Only file outputs.

Begin full project analysis now.
"""


def run_gemini(prompt: str):
    try:
        result = subprocess.run(
            ["gemini", "chat", "--model", "gemini-2.5-flash", prompt],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout
    except subprocess.CalledProcessError as e:
        print("Error running Gemini CLI:")
        print(e.stderr)
        return ""


def split_and_write_files(content: str):
    pattern = r"=== FILE: (.*?) ===\n"
    matches = list(re.finditer(pattern, content))

    if not matches:
        print("No files detected in output.")
        return

    total_files = len(matches)
    print(f"Processing {total_files} files...")

    for i, match in enumerate(matches):
        filename = match.group(1).strip()
        start = match.end()
        end = matches[i + 1].start() if i + 1 < len(matches) else len(content)
        file_content = content[start:end].strip()

        path = Path(filename)
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(file_content + "\n", encoding="utf-8")

        percentage = (i + 1) / total_files * 100
        print(f"âœ” Generated: {filename} ({percentage:.0f}%)")


def main():
    print("Starting documentation generation...")
    existing_doc = read_existing_doc()
    prompt = build_prompt(existing_doc)
    print("Calling Gemini CLI to generate documentation...")
    output = run_gemini(prompt)

    Path(OUTPUT_FILE).write_text(output, encoding="utf-8")
    split_and_write_files(output)

    print("\nDocumentation generation completed.")


if __name__ == "__main__":
    main()
